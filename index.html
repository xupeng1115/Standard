<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<title></title>
</head>
<body>
	<h2>HTML规范</h2>
	<ol>
		<li>
			<h3>推荐使用HTML5的文档类型声明：&lt;!DOCTYPE html&gt;</h3>
		</li>
		<li>
			<h3>无内容元素标签不闭合使用&lt;br&gt;而非 &lt;br /&gt;</h3>
		</li>
		<li>
			<h3>不省略可选标签</h3>
		</li>
		<li>
			<h3>脚本写在body闭合前</h3>
		</li>
		<li>
			<h3>标签选用语义化ul,p,a,div,span等</h3>
		</li>
		<li>
			<h3>图片，视频，canvas动画等，确保有可替代的接入接口,比如alt,dec,titile等</h3>
		</li>
		<li>
			<h3>关注点分离html,css,js分离,尽可能少的引入样式和脚本文件，不使用行内样式，行内脚本，不使用表象元素b,u,center,font</h3>
		</li>
		<li>
			<h3>使用:before,:after</h3>
		</li>
		<li>
			<h3>省略样式表和脚本上的type属性</h3>
		</li>
		<li>
			<h3>使用锚点,打开链接可直接定位元素位置</h3>
		</li>
		<li>
			<h3>使用双引号，不使用单引号</h3>
		</li>
	</ol>
	<h2>CSS规范</h2>	
	<ol>
		<li>
			<h3>
				语义化名称
			</h3>
		</li>
		<li>
			<h3>合理避免使用id,尽量使用class</h3>
		</li>
		<li>
			<h3>避免使用标签名</h3>
		</li>
		<li>
			<h3>不使用元素选择器</h3>
		</li>
		<li>
			<h3>尽量使用直接子选择器，不使用后代选择器,尽可能精确</h3>
		</li>
		<li>
			<h3>使用缩写属性</h3>
		</li>
		<li>
			<h3>省略0值后面的单位</h3>
		</li>
		<li>
			<h3>color使用小写十六进制的表示法</h3>
		</li>
		<li>
			<h3>class名的分隔符使用连字符</h3>
		</li>
		<li>
			<h3>不使用hacks</h3>
		</li>
		<li>
			<h3>
				属性结构化
				display;
				width,height;
				position,left,top,right;
				overflow,float,clear;
				margin,padding;
				表现性属性
				background,border;
				font,text;
			</h3>
		</li>
		<li>
			<h3>都有换行和;,保证结束：后有空格</h3>
		</li>
		<li>
			<h3>选择器都换行</h3>
		</li>
		<li>
			<h3>规则之间都有一个换行</h3>
		</li>
		<li>
			<h3>属性选择器使用双引号</h3>
		</li>
		<li>
			<h3>SCSS嵌套避免无用css</h3>
		</li>
		<li>
			<h3>SCSS嵌套选择器有空行</h3>
		</li>
		<li>
			<h3>SCSS嵌套中使用媒体查询</h3>
		</li>
		<li>
			<h3>
				SCSS嵌套顺序；
				当前选择器的样式属性；
				父级选择器的伪类选择器 (:first-letter, :hover, :active etc)
				伪类元素 (:before and :after)
				父级选择器的声明样式 (.selected, .active, .enlarged etc.)
				用Sass的上下文媒体查询；
				子选择器作为最后的部分；
			</h3>
		</li>
	</ol>
	<h2>Javascript规范</h2>
	<ol>
		<li>
			<h3>
				不使用全局变量命名方式，使用自执行函数方式(function(a,b,c){...}(window.a='',window.b='',window.c));
			</h3>
		</li>
		<li>
			<h3>
				脚本文件从立即执行函数开始，使用在内部第一行使用'use strict'，确保错误检查和代码健壮性；
			</h3>
		</li>
		<li>
			<h3>
				总是使用var声明变量,所用用到的变量都统一声明到函数内部顶部，只用一个var，用,分割开；
			</h3>
		</li>
		<li>
			<h3>
				避免使用==类型转换，使用===判断
			</h3>
		</li>
		<li>
			<h3>
				使用真假判断，不关心判断过程
			</h3>
		</li>
		<li>
			<h3>
				使用变量赋值逻辑操作:x=x||y||1,经常用来设定默认赋值；
			</h3>
		</li>
		<li>
			<h3>
				总是使用分号；分号在表达式的结尾，不在函数的结尾
			</h3>
		</li>
		<li>
			<h3>使用嵌套函数,隐藏辅助函数</h3>
		</li>
		<li>
			<h3>
				语句块中不要用函数声明；函数声明在顶部，但是可以使用变量赋值
			</h3>
		</li>
		<li>
			<h3>
				可以使用throw抛出一个对象来描述错误
			</h3>
		</li>
		<li>
			<h3>
				使用标准特性，例如：string.charAt(0),不适用string[0];
			</h3>
		</li>
		<li>
			<h3>
				使用闭包，理解闭包，访问保存函数内部的变量的值；
			</h3>
		</li>
		<li>
			<h3>
				不要在循环语句中创建函数，容易产生闭包；
			</h3>
		</li>
		<li>
			<h3>
				不用eval函数
			</h3>
		</li>
		<li>
			<h3>
				this关键字,指向全局或者调用者的定义域或者DOM树的某一节点（事件处理）或者指向一个新创建的对象,还有可能指向其他对象（call,apply）;
			</h3>
		</li>
		<li>
			<h3>
				首选函数编程
			</h3>
		</li>
		<li>
			<h3>
				使用ES5数组和对象的属性的迭代；
			</h3>
		</li>
		<li>
			<h3>
				不使用switch语句
			</h3>
		</li>
		<li>
			<h3>
				使用数组和对象字面量；
			</h3>
		</li>
		<li>
			<h3>
				不修改內建对象的原型链；
			</h3>
		</li>
		<li>
			<h3>
				自定义toString()来控制对象字符串化；
			</h3>
		</li>
		<li>
			<h3>
				一元操作符一般不使用圆括号，delete,typeof void ,return ,throw new case等;
			</h3>
		</li>
		<li>
			<h3>
				统一使用单引号拼接HTML字符串；,return 后面添加；
			</h3>
		</li>
		<li>
			<h3>
				使用三元条件判断,复杂时不使用；
			</h3>
		<li>
			<h3>
				
			</h3>
		</li>
		</li>
	</ol>
	
	<script>
		(function(log){
			  'use strict';
			 
			  var a = 10;
			 
			  i = 5;
			 
			  x();
			 
			  for(var i; i < a; i++) {
			    log(b);
			    var b = i * i;
			  }
			 
			  if(a === 10) {
			    f = function() {
			      log(a);
			    };
			    f();
			 
			    var f;
			  }
			 
			  function x() {
			    log('Mr. X!');
			  }
			 
			}(window.console.log));
			
			(function(log){
			  'use strict';
//			 var name='xiaoming';
			  log('0' == 0); // true
			  log('' == false); // true
			  log('1' == true); // true
			  log(null == undefined); // true
			 
			  var x = {
			    valueOf: function() {
			      return 'X';
			    }
			  };
			  log(x == 'X');
			 
			 if(name !== undefined) {
			 	console.log(name);
//			  throw {
//			    name: 'System Error',
//			    message: 'A name should always be specified!'
//			  }
			}

			}(window.console.log));
			
			//继承
			(function(log){
			  	'use strict';
				//父类构造函数
			  	function Apple(name) {
			    	this.name = name;
			  	}
				//给父类的prototype上定义一个方法让父类的实例可以继承这个方法，继承了父类的子类也可以调用此方法
			  	Apple.prototype.eat = function() {
			   		log('Eating ' + this.name);
			  	};
				//子类构造函数
			  	function GrannySmithApple(name) {
			  		//让子类可以调用父类的构造函数来实现子类的实例对象
			    	Apple.prototype.constructor.call(this, name);
			  	}

				//把父类的实例对象赋值给子类的prototype，让子类实现继承父类
			  	GrannySmithApple.prototype = Object.create(Apple.prototype);
				//把子类的prototype对象的指向的构造函数指向子类自己的构造函数
			  	GrannySmithApple.prototype.constructor = GrannySmithApple;
			 	//给子类的prototype对象上定义一个方法让子类的实例可以继承这个方法，继承了子类的子类也可以调用此方法
			  	GrannySmithApple.prototype.eat = function() {
			  		//首先在内部先实现父类的方法方法操作
			    	Apple.prototype.eat.call(this);
			    	//然后定义子类自己的方法操作；
			    	log('Poor Grany Smith');
			  	};
				
				// Instantiation
				var apple = new Apple('Test Apple');
				var grannyApple = new GrannySmithApple('xiaoming');
				log(grannyApple);
				log(apple.name); // Test Apple
				log(grannyApple.name); // Granny Smith
				
				// Instance checks
				log(apple instanceof Apple); // true
				log(apple instanceof GrannySmithApple); // false
				
				log(grannyApple instanceof Apple); // true
				log(grannyApple instanceof GrannySmithApple); // true

				grannyApple.eat(); // Eating Granny Smith\nPoor Grany Smith
			
			}(window.console.log));
			
			//闭包
			(function(log){
				//这不是闭包
				function foo(x){
					var tmp =3;
					function bar(y){
						log(x+y+(++tmp));
					}
					bar(10);
				}
				foo(2);
				
				//这是闭包
				function foo2(x){
					var tmp=3;
					return function(y){
						log(x+y+(++tmp));
					}
				}
				
				var bar=foo2(2); //bar 现在是一个闭包
				bar(10);
				bar(10);
				
				//这也是闭包
				function foo3(x){
					var tmp=3;
					return function(y){
						log(x+y+tmp);
						x.memb =x.memb ?x.memb +1:1;
						log(x.a);
					}
				}
				
				var age=new Number(2);
				var bar2=foo3(age);
				bar2(10);
				bar2(10);
				
			}(window.console.log));
			
			//访问函数内部的变量
			function f1(){
				var n=999;
				
				nAdd=function(){
					n+=1;
				}
				
				return function(){
					console.log(n++);
				}
			}
			
			var result=f1();
			result();
			nAdd();
			
			result();
			
			var name="The Window";
			
			var obj={
				name:'My Object',
				
				getNameFunc:function(){
					return function(){
						return this.name;
					}
				}
			}

			console.log(obj.getNameFunc()());
			
			(function(log,w){
				'use strict';
				var numbers=[1,2,3],
					i;
				function logNumber(index,nubmber){
					return function(){
						log('Index' + i + 'with number' + numbers[i]);
					}
				}
				for(var i=0;i<numbers.length;i++){
					w.setTimeout(logNumber(i,numbers[i]),0);
				}
			}(window.console.log,window));
			
			(function(log){
				var arr=[10,100,1000,10000],
					sum=0,
					i;
				for(i=0;i<arr.length;i++){
					sum+=arr[i];
				}
				log('The sum of array' + arr + 'is:' +sum);
			}(window.console.log));
			
			(function(log){
				var arr=[1,10,100,1000,10000];
				var sum=arr.reduce(function(prevValue,currentValue){
					return prevValue+currentValue;
				},0)
				log('The sum of array ' + arr + ' is:' +sum);
			}(window.console.log));
			
			(function(log){
  				'use strict';
 
  				var numbers = [11, 3, 7, 9, 100, 20, 14, 10];
 
  				var numbersGreaterTen = numbers.filter(function(element) {
    				return element > 10;
  				});
 
  				log('From the list of numbers ' + numbers + ' only ' + numbersGreaterTen + ' are greater than ten');
 
			}(window.console.log));
			(function(log){
  				'use strict';
 
  				[1, 2, 3, 4, 5].every(function(element, index, arr) {
    				log(element + ' at index ' + index + ' in array ' + arr);
 
    				if(index !== 3) {
      					return true;
    				}
  				});
 
				var obj = {
				    a: 'A',
				    b: 'B',
				    'c-d-e': 'CDE'
				};
 
  				Object.keys(obj).forEach(function(element, index, arr) {
    				log('Key ' + element + ' has value ' + obj[element]);
  				});

			}(window.console.log));
			
			
	</script>
	
</body>
</html>
